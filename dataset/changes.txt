-------------------------------------------------------
if <complex comparison> and <other complex comparison>:
    # do something

++++++++++++++++++++++++++++++++++++++++++++

cond1 = <complex comparison>
cond2 = <other complex comparison>
if cond1 and cond2:
    # do something

-----------------------------------------------------------

def complex_function(a, b, c):
    if not a:
        return None  # Raising an exception might be better
    if not b:
        return None  # Raising an exception might be better
    # Some complex code trying to compute x from a, b and c
    # Resist temptation to return x if succeeded
    if not x:
        # Some Plan-B computation of x
    return x  # One single exit point for the returned value x will help
              # when maintaining the code.

--------------------------------------------------------------

Check if a variable equals a constant

You don’t need to explicitly compare a value to True, or None, or 0 – you can just add it to the if statement. See Truth Value Testing for a list of what is considered false.

Bad:

if attr == True:
    print 'True!'

if attr == None:
    print 'attr is None!'

Good:

# Just check the value
if attr:
    print 'attr is truthy!'

# or check for the opposite
if not attr:
    print 'attr is falsey!'

# or, since None is considered false, explicitly check for it
if attr is None:
    print 'attr is None!'

---------------------------------------------------------------------


Access a Dictionary Element

Don’t use the dict.has_key() method. Instead, use x in d syntax, or pass a default argument to dict.get().

Bad:

d = {'hello': 'world'}
if d.has_key('hello'):
    print d['hello']    # prints 'world'
else:
    print 'default_value'

Good:

d = {'hello': 'world'}

print d.get('hello', 'default_value') # prints 'world'
print d.get('thingy', 'default_value') # prints 'default_value'

# Or:
if 'hello' in d:
    print d['hello']

------------------------------------------------------------------

Short Ways to Manipulate Lists

List comprehensions provide a powerful, concise way to work with lists.

Generator expressions follow almost the same syntax as list comprehensions but return a generator instead of a list.

Creating a new list requires more work and uses more memory. If you are just going to loop through the new list, prefer using an iterator instead.

Bad:

# needlessly allocates a list of all (gpa, name) entires in memory
valedictorian = max([(student.gpa, student.name) for student in graduates])

Good:

valedictorian = max((student.gpa, student.name) for student in graduates)

Use list comprehensions when you really need to create a second list, for example if you need to use the result multiple times.


Never use a list comprehension just for its side effects.

Bad:

[print(x) for x in sequence]

Good:

for x in sequence:
    print(x)

------------------------------------------------------------------------

Bad:

Never remove items from a list while you are iterating through it.

# Filter elements greater than 4
a = [3, 4, 5]
for i in a:
    if i > 4:
        a.remove(i)

Don’t make multiple passes through the list.

while i in a:
    a.remove(i)

Good:

Use a list comprehension or generator expression.

# comprehensions create a new list object
filtered_values = [value for value in sequence if value != x]

# generators don't create another list
filtered_values = (value for value in sequence if value != x)

------------------------------------------------------------------------


Read From a File

Use the with open syntax to read from files. This will automatically close files for you.

Bad:

f = open('file.txt')
a = f.read()
print a
f.close()

Good:

with open('file.txt') as f:
    for line in f:
        print line

The with statement is better because it will ensure you always close the file, even if an exception is raised inside the with block.

--------------------------------------------------------------------

# Not recommended
my_list = []
if not len(my_list):
    print('List is empty!')

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Recommended
my_list = []
if not my_list:
    print('List is empty!')

--------------------------------------------------------------------

# Recommended
if x is not None:
    return 'x exists!'

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Not recommended
if not x is None:
    return 'x exists!'

--------------------------------------------------------------------

def calculation(*args):
    """calculation of the total"""

    x, y = args
    return (x+y)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#good

def calculation(x,y):
    """calculation of the total"""

    total = x + y
    return (total)

----------------------------------------------------------------------